# 公司名字列表模块 - 免费数据源实施指南

## 免费数据源方案

### 🎯 推荐免费组合方案
```
主数据源: AKShare（完全免费，无需注册）
补充数据源: 东方财富网API（免费，无需注册）
验证数据源: 新浪财经API（免费，无需注册）
备用数据源: Tushare免费版（需注册，但免费）
```

### 数据源特点对比

| 数据源 | 注册要求 | 调用限制 | 数据完整性 | 稳定性 | 推荐指数 |
|--------|----------|----------|------------|---------|----------|
| AKShare | 无需注册 | 无明确限制 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 东方财富 | 无需注册 | ~60次/分钟 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| 新浪财经 | 无需注册 | ~60次/分钟 | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| Tushare免费版 | 需注册 | 200次/分钟 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

## 详细执行步骤

### 第一步：环境准备（预计时间：30分钟）

#### 1.1 创建Python虚拟环境
```bash
# 切换到项目目录
cd "第一层模块/公司名字列表"

# 创建虚拟环境
python -m venv venv

# 激活虚拟环境（Windows）
venv\Scripts\activate

# 激活虚拟环境（Linux/Mac）
source venv/bin/activate
```

#### 1.2 安装必要的依赖包
```bash
# 安装核心依赖
pip install akshare pandas requests mysql-connector-python schedule

# 或者使用完整的requirements文件
pip install -r requirements.txt
```

#### 1.3 验证环境安装
```bash
python -c "import akshare as ak; print('AKShare版本:', ak.__version__)"
python -c "import pandas as pd; print('Pandas版本:', pd.__version__)"
python -c "import requests; print('Requests安装成功')"
```

### 第二步：数据源测试（预计时间：30分钟）

#### 2.1 测试AKShare连接
```python
# 创建测试文件：test_data_sources.py
import akshare as ak
import pandas as pd

def test_akshare():
    """测试AKShare数据获取"""
    try:
        print("正在测试AKShare...")
        # 获取A股实时行情（只取前10条测试）
        df = ak.stock_zh_a_spot_em()
        print(f"AKShare测试成功，获取到 {len(df)} 条股票数据")
        print("前5条数据:")
        print(df.head())
        return True
    except Exception as e:
        print(f"AKShare测试失败: {e}")
        return False

if __name__ == "__main__":
    test_akshare()
```

#### 2.2 测试东方财富API
```python
import requests
import json

def test_eastmoney():
    """测试东方财富API"""
    url = "http://80.push2.eastmoney.com/api/qt/clist/get"
    params = {
        'pn': 1,
        'pz': 20,  # 只获取20条测试
        'po': 1,
        'np': 1,
        'ut': 'bd1d9ddb04089700cf9c27f6f7426281',
        'fltt': 2,
        'invt': 2,
        'fid': 'f3',
        'fs': 'm:0+t:6,m:0+t:80,m:1+t:2,m:1+t:23',
        'fields': 'f12,f14,f2,f3,f62,f184'
    }
    
    try:
        print("正在测试东方财富API...")
        response = requests.get(url, params=params, timeout=10)
        data = response.json()
        if data.get('rc') == 0 and data.get('data'):
            stocks = data['data']['diff']
            print(f"东方财富API测试成功，获取到 {len(stocks)} 条股票数据")
            for stock in stocks[:3]:  # 显示前3条
                print(f"  {stock['f12']}: {stock['f14']}")
            return True
        else:
            print("东方财富API返回数据格式异常")
            return False
    except Exception as e:
        print(f"东方财富API测试失败: {e}")
        return False

# 运行测试
test_eastmoney()
```

#### 2.3 测试新浪财经API
```python
import requests

def test_sina():
    """测试新浪财经API"""
    try:
        print("正在测试新浪财经API...")
        # 获取沪深A股列表
        url = "http://vip.stock.finance.sina.com.cn/quotes_service/api/json_v2.php/Market_Center.getHQNodeData"
        params = {
            'page': 1,
            'num': 20,
            'sort': 'symbol',
            'asc': 1,
            'node': 'hs_a'
        }
        
        response = requests.get(url, params=params, timeout=10)
        data = response.json()
        
        if isinstance(data, list) and len(data) > 0:
            print(f"新浪财经API测试成功，获取到 {len(data)} 条股票数据")
            for stock in data[:3]:  # 显示前3条
                print(f"  {stock.get('symbol')}: {stock.get('name')}")
            return True
        else:
            print("新浪财经API返回数据格式异常")
            return False
    except Exception as e:
        print(f"新浪财经API测试失败: {e}")
        return False

# 运行测试
test_sina()
```

### 第三步：数据库准备（预计时间：15分钟）

#### 3.1 确保MySQL运行
```bash
# 检查MySQL服务状态（Windows）
net start mysql

# 连接测试
mysql -u root -p
```

#### 3.2 创建数据库和表
```bash
# 运行数据库初始化脚本
cd "../../数据库配置"
python init_tables.py
```

#### 3.3 验证数据库连接
```python
# 创建测试文件：test_database.py
import sys
import os
sys.path.append('../../数据库配置')

from database_config import get_database_manager

def test_database():
    """测试数据库连接"""
    db_manager = get_database_manager()
    
    if db_manager.create_database():
        print("数据库创建成功")
        
        if db_manager.connect():
            print("数据库连接成功")
            
            # 测试查询
            result = db_manager.execute_query("SHOW TABLES")
            print(f"数据库中的表: {result}")
            
            db_manager.disconnect()
            return True
        else:
            print("数据库连接失败")
            return False
    else:
        print("数据库创建失败")
        return False

if __name__ == "__main__":
    test_database()
```

### 第四步：数据采集实现（预计时间：2小时）

#### 4.1 创建数据采集器
```python
# 创建文件：company_collector.py
import akshare as ak
import requests
import pandas as pd
import time
import logging
from datetime import datetime
import sys
import os

# 添加配置路径
sys.path.append('.')
sys.path.append('../../数据库配置')

from config import *
from database_config import get_database_manager

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('company_collector.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class CompanyDataCollector:
    """公司数据采集器"""
    
    def __init__(self):
        self.db_manager = get_database_manager()
        self.collected_data = []
        
    def collect_from_akshare(self):
        """从AKShare采集数据"""
        try:
            logger.info("开始从AKShare采集数据...")
            df = ak.stock_zh_a_spot_em()
            
            # 数据清洗和格式化
            processed_data = []
            for _, row in df.iterrows():
                company_data = {
                    'stock_code': row['代码'],
                    'company_name': row['名称'],
                    'market': 'SZ' if row['代码'].startswith(('000', '002', '300')) else 'SH',
                    'market_cap': row.get('总市值', 0),
                    'float_market_cap': row.get('流通市值', 0),
                    'data_source': 'akshare',
                    'data_date': datetime.now().date()
                }
                processed_data.append(company_data)
            
            logger.info(f"AKShare采集完成，获取 {len(processed_data)} 条数据")
            return processed_data
            
        except Exception as e:
            logger.error(f"AKShare数据采集失败: {e}")
            return []
    
    def collect_from_eastmoney(self):
        """从东方财富采集数据"""
        try:
            logger.info("开始从东方财富采集数据...")
            url = "http://80.push2.eastmoney.com/api/qt/clist/get"
            params = {
                'pn': 1,
                'pz': 5000,
                'po': 1,
                'np': 1,
                'ut': 'bd1d9ddb04089700cf9c27f6f7426281',
                'fltt': 2,
                'invt': 2,
                'fid': 'f3',
                'fs': 'm:0+t:6,m:0+t:80,m:1+t:2,m:1+t:23',
                'fields': 'f12,f14,f2,f3,f62,f184,f116,f117'
            }
            
            response = requests.get(url, params=params, timeout=30)
            data = response.json()
            
            if data.get('rc') == 0 and data.get('data'):
                processed_data = []
                for stock in data['data']['diff']:
                    company_data = {
                        'stock_code': stock['f12'],
                        'company_name': stock['f14'],
                        'market': 'SZ' if stock['f12'].startswith(('000', '002', '300')) else 'SH',
                        'current_price': stock.get('f2', 0),
                        'change_percent': stock.get('f3', 0),
                        'data_source': 'eastmoney',
                        'data_date': datetime.now().date()
                    }
                    processed_data.append(company_data)
                
                logger.info(f"东方财富采集完成，获取 {len(processed_data)} 条数据")
                return processed_data
            else:
                logger.error("东方财富API返回数据格式异常")
                return []
                
        except Exception as e:
            logger.error(f"东方财富数据采集失败: {e}")
            return []
    
    def merge_data(self, akshare_data, eastmoney_data):
        """合并多源数据"""
        logger.info("开始合并多源数据...")
        
        # 以AKShare为主，东方财富为补充
        merged_data = {}
        
        # 先处理AKShare数据
        for item in akshare_data:
            code = item['stock_code']
            merged_data[code] = item
        
        # 补充东方财富数据
        for item in eastmoney_data:
            code = item['stock_code']
            if code in merged_data:
                # 补充价格信息
                merged_data[code]['current_price'] = item.get('current_price', 0)
                merged_data[code]['change_percent'] = item.get('change_percent', 0)
            else:
                # 新增数据
                merged_data[code] = item
        
        result = list(merged_data.values())
        logger.info(f"数据合并完成，总计 {len(result)} 条数据")
        return result
    
    def save_to_database(self, data):
        """保存数据到数据库"""
        if not data:
            logger.warning("没有数据需要保存")
            return False
        
        try:
            if not self.db_manager.connect():
                logger.error("数据库连接失败")
                return False
            
            # 批量插入数据
            success_count = 0
            for item in data:
                # 构建插入SQL
                sql = """
                INSERT INTO company_list 
                (company_name, stock_code, market, market_cap, current_price, 
                 change_percent, data_source, data_date, created_at, updated_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, NOW(), NOW())
                ON DUPLICATE KEY UPDATE
                company_name = VALUES(company_name),
                market_cap = VALUES(market_cap),
                current_price = VALUES(current_price),
                change_percent = VALUES(change_percent),
                data_source = VALUES(data_source),
                data_date = VALUES(data_date),
                updated_at = NOW()
                """
                
                params = (
                    item['company_name'],
                    item['stock_code'],
                    item['market'],
                    item.get('market_cap', 0),
                    item.get('current_price', 0),
                    item.get('change_percent', 0),
                    item['data_source'],
                    item['data_date']
                )
                
                if self.db_manager.execute_update(sql, params):
                    success_count += 1
            
            logger.info(f"数据保存完成，成功保存 {success_count} 条数据")
            return True
            
        except Exception as e:
            logger.error(f"数据保存失败: {e}")
            return False
        finally:
            self.db_manager.disconnect()
    
    def run_collection(self):
        """执行完整的数据采集流程"""
        logger.info("开始执行数据采集任务...")
        start_time = time.time()
        
        # 采集数据
        akshare_data = self.collect_from_akshare()
        time.sleep(2)  # 避免请求过快
        
        eastmoney_data = self.collect_from_eastmoney()
        
        # 合并数据
        merged_data = self.merge_data(akshare_data, eastmoney_data)
        
        # 保存数据
        if self.save_to_database(merged_data):
            elapsed_time = time.time() - start_time
            logger.info(f"数据采集任务完成，耗时 {elapsed_time:.2f} 秒")
            return True
        else:
            logger.error("数据采集任务失败")
            return False

def main():
    """主函数"""
    collector = CompanyDataCollector()
    collector.run_collection()

if __name__ == "__main__":
    main()
```

### 第五步：定时任务配置（预计时间：30分钟）

#### 5.1 创建调度器
```python
# 创建文件：scheduler.py
import schedule
import time
import logging
from datetime import datetime
from company_collector import CompanyDataCollector

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def run_daily_collection():
    """执行日常数据采集"""
    logger.info("开始执行定时数据采集任务...")
    collector = CompanyDataCollector()
    
    try:
        success = collector.run_collection()
        if success:
            logger.info("定时数据采集任务执行成功")
        else:
            logger.error("定时数据采集任务执行失败")
    except Exception as e:
        logger.error(f"定时任务执行异常: {e}")

def main():
    """主调度程序"""
    # 配置定时任务
    schedule.every().day.at("09:00").do(run_daily_collection)  # 每天9点执行
    schedule.every().day.at("15:30").do(run_daily_collection)  # 每天15:30执行
    
    logger.info("调度器启动，等待执行定时任务...")
    logger.info("定时任务安排:")
    logger.info("- 每天 09:00 执行数据采集")
    logger.info("- 每天 15:30 执行数据采集")
    
    while True:
        schedule.run_pending()
        time.sleep(60)  # 每分钟检查一次

if __name__ == "__main__":
    main()
```

### 第六步：测试和验证（预计时间：30分钟）

#### 6.1 单元测试
```bash
# 测试数据采集
python company_collector.py

# 检查日志文件
type company_collector.log
```

#### 6.2 数据验证
```python
# 创建验证脚本：validate_data.py
import sys
sys.path.append('../../数据库配置')
from database_config import get_database_manager

def validate_collected_data():
    """验证采集的数据"""
    db_manager = get_database_manager()
    
    if not db_manager.connect():
        print("数据库连接失败")
        return
    
    try:
        # 检查数据总数
        result = db_manager.execute_query("SELECT COUNT(*) FROM company_list")
        total_count = result[0][0] if result else 0
        print(f"数据库中总计 {total_count} 条公司数据")
        
        # 检查今日数据
        result = db_manager.execute_query(
            "SELECT COUNT(*) FROM company_list WHERE data_date = CURDATE()"
        )
        today_count = result[0][0] if result else 0
        print(f"今日新增 {today_count} 条数据")
        
        # 检查市场分布
        result = db_manager.execute_query(
            "SELECT market, COUNT(*) FROM company_list GROUP BY market"
        )
        print("市场分布:")
        for row in result:
            print(f"  {row[0]}: {row[1]} 家公司")
        
        # 检查数据源分布
        result = db_manager.execute_query(
            "SELECT data_source, COUNT(*) FROM company_list GROUP BY data_source"
        )
        print("数据源分布:")
        for row in result:
            print(f"  {row[0]}: {row[1]} 条数据")
        
        # 检查数据质量
        result = db_manager.execute_query(
            "SELECT COUNT(*) FROM company_list WHERE company_name IS NULL OR company_name = ''"
        )
        null_name_count = result[0][0] if result else 0
        
        result = db_manager.execute_query(
            "SELECT COUNT(*) FROM company_list WHERE stock_code IS NULL OR stock_code = ''"
        )
        null_code_count = result[0][0] if result else 0
        
        print(f"数据质量检查:")
        print(f"  缺失公司名称: {null_name_count} 条")
        print(f"  缺失股票代码: {null_code_count} 条")
        
        if null_name_count == 0 and null_code_count == 0:
            print("✅ 数据质量检查通过")
        else:
            print("❌ 数据质量存在问题，需要检查")
            
    finally:
        db_manager.disconnect()

if __name__ == "__main__":
    validate_collected_data()
```

### 第七步：监控和维护（预计时间：1小时）

#### 7.1 创建监控脚本
```python
# 创建文件：monitor.py
import sys
import time
from datetime import datetime, timedelta
sys.path.append('../../数据库配置')
from database_config import get_database_manager

class DataMonitor:
    """数据监控器"""
    
    def __init__(self):
        self.db_manager = get_database_manager()
    
    def check_data_freshness(self):
        """检查数据新鲜度"""
        if not self.db_manager.connect():
            return False
        
        try:
            # 检查最新数据时间
            result = self.db_manager.execute_query(
                "SELECT MAX(data_date) FROM company_list"
            )
            
            if result and result[0][0]:
                latest_date = result[0][0]
                today = datetime.now().date()
                
                if latest_date == today:
                    print("✅ 数据是最新的")
                    return True
                elif latest_date == today - timedelta(days=1):
                    print("⚠️ 数据延迟1天")
                    return True
                else:
                    print(f"❌ 数据严重延迟，最新数据日期: {latest_date}")
                    return False
            else:
                print("❌ 没有找到任何数据")
                return False
                
        finally:
            self.db_manager.disconnect()
    
    def check_data_completeness(self):
        """检查数据完整性"""
        if not self.db_manager.connect():
            return False
        
        try:
            # 检查A股数量是否正常（大约4000-5000家）
            result = self.db_manager.execute_query(
                "SELECT COUNT(*) FROM company_list WHERE status = 'active'"
            )
            
            count = result[0][0] if result else 0
            
            if count > 4000:
                print(f"✅ 数据完整性正常，共 {count} 家公司")
                return True
            elif count > 3000:
                print(f"⚠️ 数据可能不完整，共 {count} 家公司")
                return True
            else:
                print(f"❌ 数据明显不完整，仅 {count} 家公司")
                return False
                
        finally:
            self.db_manager.disconnect()
    
    def run_health_check(self):
        """运行健康检查"""
        print(f"开始数据健康检查 - {datetime.now()}")
        
        freshness_ok = self.check_data_freshness()
        completeness_ok = self.check_data_completeness()
        
        if freshness_ok and completeness_ok:
            print("✅ 系统健康状态良好")
            return True
        else:
            print("❌ 系统存在问题，需要人工介入")
            return False

def main():
    """主监控程序"""
    monitor = DataMonitor()
    
    while True:
        try:
            monitor.run_health_check()
            print("-" * 50)
            time.sleep(3600)  # 每小时检查一次
        except KeyboardInterrupt:
            print("监控程序停止")
            break
        except Exception as e:
            print(f"监控程序异常: {e}")
            time.sleep(300)  # 异常时5分钟后重试

if __name__ == "__main__":
    main()
```

#### 7.2 创建维护脚本
```python
# 创建文件：maintenance.py
import sys
sys.path.append('../../数据库配置')
from database_config import get_database_manager

def cleanup_old_data():
    """清理老旧数据"""
    db_manager = get_database_manager()
    
    if not db_manager.connect():
        return False
    
    try:
        # 删除30天前的数据
        sql = "DELETE FROM company_list WHERE data_date < DATE_SUB(CURDATE(), INTERVAL 30 DAY)"
        
        if db_manager.execute_update(sql):
            print("✅ 老旧数据清理完成")
            return True
        else:
            print("❌ 老旧数据清理失败")
            return False
            
    finally:
        db_manager.disconnect()

def optimize_database():
    """优化数据库"""
    db_manager = get_database_manager()
    
    if not db_manager.connect():
        return False
    
    try:
        # 优化表
        sql = "OPTIMIZE TABLE company_list"
        
        if db_manager.execute_update(sql):
            print("✅ 数据库优化完成")
            return True
        else:
            print("❌ 数据库优化失败")
            return False
            
    finally:
        db_manager.disconnect()

if __name__ == "__main__":
    print("开始数据库维护...")
    cleanup_old_data()
    optimize_database()
    print("数据库维护完成")
```

## 完整执行清单

### ✅ 快速启动清单（30分钟内完成）

1. **环境准备** (5分钟)
   ```bash
   cd "第一层模块/公司名字列表"
   python -m venv venv
   venv\Scripts\activate
   pip install akshare pandas requests mysql-connector-python schedule
   ```

2. **测试数据源** (10分钟)
   ```bash
   python -c "import akshare as ak; print(ak.stock_zh_a_spot_em().head())"
   ```

3. **数据库准备** (5分钟)
   ```bash
   cd "../../数据库配置"
   python init_tables.py
   ```

4. **数据采集** (5分钟)
   ```bash
   cd "../第一层模块/公司名字列表"
   python company_collector.py
   ```

5. **验证结果** (5分钟)
   ```bash
   python validate_data.py
   ```

### 📋 完整部署清单

- [ ] 环境准备和依赖安装
- [ ] 数据源连接测试
- [ ] 数据库初始化
- [ ] 数据采集器开发
- [ ] 定时任务配置
- [ ] 数据验证和监控
- [ ] 维护脚本部署

### 🚨 注意事项

1. **网络连接**: 确保能正常访问外网API
2. **请求频率**: 避免请求过于频繁被限制
3. **数据质量**: 定期检查数据完整性
4. **错误处理**: 关注日志文件中的错误信息
5. **备份策略**: 定期备份重要数据

### 📞 故障排除

- **数据源无法访问**: 检查网络连接，尝试更换数据源
- **数据库连接失败**: 检查MySQL服务和配置
- **数据质量问题**: 运行验证脚本，检查数据源状态
- **性能问题**: 调整批量大小和并发数量

这个免费方案可以满足基本的数据采集需求，后续可以根据业务发展情况考虑升级到付费数据源。

