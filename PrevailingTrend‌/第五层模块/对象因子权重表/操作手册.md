# 对象因子权重表模块 - 操作手册

## 模块概述
对象因子权重表模块负责动态计算和管理各类因子在风险评估和投资决策中的权重配置。该模块基于市场环境、行业特征和历史表现，智能调整因子权重，为第六层的曲线预测分析提供优化的权重参数，确保模型在不同市场状态下的有效性。

## 数据输入依赖

### 第四层模块数据
- **公司分值表**: 各维度评分和综合排名
- **行业分值表**: 行业层面的评分数据
- **行业+公司分值表**: 行业内公司相对表现

### 市场环境数据
- **市场状态指标**: 牛市/熊市/震荡市识别
- **波动率指标**: VIX、历史波动率
- **流动性指标**: 市场流动性状况
- **情绪指标**: 恐慌贪婪指数

### 历史回测数据
- **因子表现历史**: 各因子的历史收益和风险
- **相关性矩阵**: 因子间的动态相关性
- **有效性评估**: 因子预测能力的时序变化

## 权重体系设计

### 1. 因子分类体系

#### 基本面因子权重
```python
FUNDAMENTAL_FACTORS = {
    'profitability': {
        'roe': {'base_weight': 0.15, 'range': [0.08, 0.25]},
        'roa': {'base_weight': 0.10, 'range': [0.05, 0.18]},
        'gross_margin': {'base_weight': 0.08, 'range': [0.04, 0.15]},
        'net_margin': {'base_weight': 0.12, 'range': [0.06, 0.20]}
    },
    'growth': {
        'revenue_growth': {'base_weight': 0.12, 'range': [0.06, 0.20]},
        'profit_growth': {'base_weight': 0.15, 'range': [0.08, 0.25]},
        'eps_growth': {'base_weight': 0.10, 'range': [0.05, 0.18]}
    },
    'financial_health': {
        'debt_ratio': {'base_weight': 0.10, 'range': [0.05, 0.18]},
        'current_ratio': {'base_weight': 0.08, 'range': [0.04, 0.15]},
        'cash_flow_ratio': {'base_weight': 0.12, 'range': [0.06, 0.20]}
    }
}
```

#### 技术面因子权重
```python
TECHNICAL_FACTORS = {
    'momentum': {
        'price_momentum_1m': {'base_weight': 0.12, 'range': [0.05, 0.25]},
        'price_momentum_3m': {'base_weight': 0.10, 'range': [0.04, 0.20]},
        'relative_strength': {'base_weight': 0.08, 'range': [0.03, 0.15]}
    },
    'volatility': {
        'historical_volatility': {'base_weight': 0.08, 'range': [0.03, 0.15]},
        'beta': {'base_weight': 0.06, 'range': [0.02, 0.12]}
    },
    'volume': {
        'volume_trend': {'base_weight': 0.05, 'range': [0.02, 0.10]},
        'turnover_rate': {'base_weight': 0.04, 'range': [0.01, 0.08]}
    }
}
```

#### 市场因子权重
```python
MARKET_FACTORS = {
    'valuation': {
        'pe_ratio': {'base_weight': 0.12, 'range': [0.06, 0.20]},
        'pb_ratio': {'base_weight': 0.10, 'range': [0.05, 0.18]},
        'ps_ratio': {'base_weight': 0.08, 'range': [0.04, 0.15]}
    },
    'liquidity': {
        'market_cap': {'base_weight': 0.06, 'range': [0.02, 0.12]},
        'avg_daily_volume': {'base_weight': 0.05, 'range': [0.02, 0.10]}
    },
    'sentiment': {
        'analyst_rating': {'base_weight': 0.08, 'range': [0.03, 0.15]},
        'institutional_holding': {'base_weight': 0.06, 'range': [0.02, 0.12]},
        'social_sentiment': {'base_weight': 0.04, 'range': [0.01, 0.08]}
    }
}
```

### 2. 动态权重调整机制

#### 市场状态感知权重调整
```python
class MarketRegimeWeightAdjuster:
    def __init__(self):
        self.regime_adjustments = {
            'bull_market': {
                'growth_factors': 1.3,      # 牛市加权成长因子
                'momentum_factors': 1.2,    # 加权动量因子
                'valuation_factors': 0.8,   # 降权估值因子
                'risk_factors': 0.7         # 降权风险因子
            },
            'bear_market': {
                'growth_factors': 0.7,      # 熊市降权成长因子
                'momentum_factors': 0.6,    # 降权动量因子
                'valuation_factors': 1.4,   # 加权估值因子
                'risk_factors': 1.5,        # 加权风险因子
                'quality_factors': 1.3      # 加权质量因子
            },
            'sideways_market': {
                'growth_factors': 1.0,      # 震荡市保持平衡
                'momentum_factors': 0.8,    # 略降权动量
                'valuation_factors': 1.2,   # 略加权估值
                'risk_factors': 1.1,        # 略加权风险
                'mean_reversion_factors': 1.3  # 加权均值回归
            }
        }
    
    def detect_market_regime(self, market_data):
        """识别市场状态"""
        # 计算市场趋势指标
        price_trend = self._calculate_price_trend(market_data['index_prices'])
        volatility_level = self._calculate_volatility(market_data['index_prices'])
        volume_pattern = self._analyze_volume_pattern(market_data['volume'])
        
        # 综合判断市场状态
        if price_trend > 0.15 and volatility_level < 0.25:
            return 'bull_market'
        elif price_trend < -0.15 and volatility_level > 0.30:
            return 'bear_market'
        else:
            return 'sideways_market'
    
    def adjust_weights_by_regime(self, base_weights, market_regime):
        """根据市场状态调整权重"""
        if market_regime not in self.regime_adjustments:
            return base_weights
        
        adjustments = self.regime_adjustments[market_regime]
        adjusted_weights = {}
        
        for factor_group, factors in base_weights.items():
            adjusted_weights[factor_group] = {}
            
            # 获取因子组的调整系数
            group_multiplier = adjustments.get(f"{factor_group}_factors", 1.0)
            
            for factor_name, weight_info in factors.items():
                original_weight = weight_info['base_weight']
                adjusted_weight = original_weight * group_multiplier
                
                # 确保权重在允许范围内
                min_weight, max_weight = weight_info['range']
                adjusted_weight = max(min_weight, min(max_weight, adjusted_weight))
                
                adjusted_weights[factor_group][factor_name] = {
                    'adjusted_weight': adjusted_weight,
                    'original_weight': original_weight,
                    'adjustment_ratio': adjusted_weight / original_weight
                }
        
        return adjusted_weights
```

#### 因子有效性动态评估
```python
class FactorEffectivenessEvaluator:
    def __init__(self, lookback_periods=252):  # 1年数据
        self.lookback_periods = lookback_periods
        
    def calculate_factor_ic(self, factor_values, future_returns):
        """计算因子信息系数(IC)"""
        # 计算Spearman相关系数
        ic_series = []
        
        for i in range(len(factor_values) - self.lookback_periods):
            period_factor = factor_values[i:i+self.lookback_periods]
            period_returns = future_returns[i:i+self.lookback_periods]
            
            ic = spearmanr(period_factor, period_returns)[0]
            ic_series.append(ic)
        
        return pd.Series(ic_series)
    
    def calculate_factor_decay(self, factor_values, returns_1d, returns_5d, returns_20d):
        """计算因子衰减特征"""
        ic_1d = self.calculate_factor_ic(factor_values, returns_1d)
        ic_5d = self.calculate_factor_ic(factor_values, returns_5d)
        ic_20d = self.calculate_factor_ic(factor_values, returns_20d)
        
        decay_analysis = {
            'ic_1d_mean': ic_1d.mean(),
            'ic_5d_mean': ic_5d.mean(),
            'ic_20d_mean': ic_20d.mean(),
            'ic_1d_std': ic_1d.std(),
            'ic_stability': ic_1d.std() / abs(ic_1d.mean()) if ic_1d.mean() != 0 else float('inf'),
            'decay_rate': (ic_1d.mean() - ic_20d.mean()) / ic_1d.mean() if ic_1d.mean() != 0 else 0
        }
        
        return decay_analysis
    
    def dynamic_weight_by_effectiveness(self, factor_performance_history):
        """基于有效性动态调整权重"""
        effectiveness_scores = {}
        
        for factor_name, performance in factor_performance_history.items():
            # 计算综合有效性得分
            ic_score = abs(performance['ic_1d_mean']) * 0.4 + \
                      abs(performance['ic_5d_mean']) * 0.3 + \
                      abs(performance['ic_20d_mean']) * 0.3
            
            stability_score = 1 / (1 + performance['ic_stability'])  # 稳定性越高得分越高
            
            decay_penalty = max(0, 1 - abs(performance['decay_rate']))  # 衰减越小得分越高
            
            effectiveness_scores[factor_name] = {
                'ic_score': ic_score,
                'stability_score': stability_score,
                'decay_penalty': decay_penalty,
                'overall_score': ic_score * 0.5 + stability_score * 0.3 + decay_penalty * 0.2
            }
        
        return effectiveness_scores
```

### 3. 行业特异性权重调整

#### 行业特征权重矩阵
```python
class IndustrySpecificWeightAdjuster:
    def __init__(self):
        self.industry_adjustments = {
            '银行': {
                'financial_health_factors': 1.5,  # 银行业更重视财务健康
                'regulatory_factors': 1.4,        # 监管因子重要
                'growth_factors': 0.8,            # 成长性相对不重要
                'valuation_factors': 1.2          # 估值因子重要
            },
            '科技': {
                'growth_factors': 1.6,            # 科技股重视成长
                'innovation_factors': 1.5,        # 创新能力关键
                'momentum_factors': 1.3,          # 动量效应明显
                'valuation_factors': 0.7,         # 传统估值指标不适用
                'volatility_factors': 0.8         # 波动率容忍度高
            },
            '医药': {
                'rd_factors': 1.7,               # 研发投入关键
                'regulatory_factors': 1.4,        # 监管审批重要
                'quality_factors': 1.3,          # 质量因子重要
                'growth_factors': 1.2,           # 稳定成长
                'momentum_factors': 0.9           # 动量效应较弱
            },
            '房地产': {
                'financial_health_factors': 1.4,  # 财务杠杆关键
                'policy_factors': 1.6,           # 政策敏感度高
                'macro_factors': 1.3,            # 宏观经济相关
                'valuation_factors': 1.2,        # 估值水平重要
                'liquidity_factors': 1.1         # 流动性考虑
            },
            '消费': {
                'brand_factors': 1.4,            # 品牌价值重要
                'margin_factors': 1.3,           # 盈利能力关键
                'market_share_factors': 1.2,     # 市场份额
                'seasonal_factors': 1.1,         # 季节性考虑
                'consumer_sentiment_factors': 1.2 # 消费者情绪
            }
        }
    
    def adjust_weights_by_industry(self, base_weights, industry_code):
        """根据行业特点调整权重"""
        industry_name = self._map_industry_code_to_name(industry_code)
        
        if industry_name not in self.industry_adjustments:
            return base_weights  # 如果没有特定调整，返回基础权重
        
        adjustments = self.industry_adjustments[industry_name]
        adjusted_weights = {}
        
        for factor_group, factors in base_weights.items():
            # 查找对应的调整系数
            adjustment_key = f"{factor_group}_factors"
            multiplier = adjustments.get(adjustment_key, 1.0)
            
            adjusted_weights[factor_group] = {}
            for factor_name, weight_info in factors.items():
                original_weight = weight_info.get('adjusted_weight', weight_info['base_weight'])
                industry_adjusted_weight = original_weight * multiplier
                
                # 确保在合理范围内
                min_weight, max_weight = weight_info['range']
                final_weight = max(min_weight, min(max_weight, industry_adjusted_weight))
                
                adjusted_weights[factor_group][factor_name] = {
                    'final_weight': final_weight,
                    'industry_adjustment': multiplier,
                    'original_weight': original_weight
                }
        
        return adjusted_weights
```

## 数据库设计

### 权重配置表
```sql
CREATE TABLE factor_weight_config (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    config_name VARCHAR(100) NOT NULL COMMENT '配置名称',
    config_version VARCHAR(20) NOT NULL COMMENT '配置版本',
    market_regime ENUM('bull_market', 'bear_market', 'sideways_market', 'all') DEFAULT 'all',
    industry_code VARCHAR(20) COMMENT '行业代码（空表示通用）',
    
    factor_category VARCHAR(50) NOT NULL COMMENT '因子类别',
    factor_name VARCHAR(100) NOT NULL COMMENT '因子名称',
    base_weight DECIMAL(8,6) NOT NULL COMMENT '基础权重',
    min_weight DECIMAL(8,6) NOT NULL COMMENT '最小权重',
    max_weight DECIMAL(8,6) NOT NULL COMMENT '最大权重',
    current_weight DECIMAL(8,6) NOT NULL COMMENT '当前权重',
    
    effectiveness_score DECIMAL(8,6) COMMENT '有效性得分',
    ic_1d DECIMAL(8,6) COMMENT '1日IC',
    ic_5d DECIMAL(8,6) COMMENT '5日IC', 
    ic_20d DECIMAL(8,6) COMMENT '20日IC',
    stability_score DECIMAL(8,6) COMMENT '稳定性得分',
    
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE,
    
    UNIQUE KEY uk_config_factor (config_name, factor_category, factor_name, market_regime, industry_code),
    INDEX idx_market_regime (market_regime),
    INDEX idx_industry_code (industry_code),
    INDEX idx_factor_category (factor_category)
) COMMENT '因子权重配置表';

-- 权重调整历史表
CREATE TABLE factor_weight_history (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    config_id BIGINT NOT NULL,
    adjustment_date DATE NOT NULL,
    old_weight DECIMAL(8,6) NOT NULL,
    new_weight DECIMAL(8,6) NOT NULL,
    adjustment_reason TEXT COMMENT '调整原因',
    adjustment_type ENUM('regime_change', 'effectiveness', 'industry_specific', 'manual') NOT NULL,
    performance_impact DECIMAL(8,6) COMMENT '对组合表现的影响',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (config_id) REFERENCES factor_weight_config(id),
    INDEX idx_adjustment_date (adjustment_date),
    INDEX idx_config_id (config_id)
) COMMENT '权重调整历史表';

-- 因子表现评估表
CREATE TABLE factor_performance_evaluation (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    factor_name VARCHAR(100) NOT NULL,
    evaluation_date DATE NOT NULL,
    evaluation_period_days INT NOT NULL COMMENT '评估周期天数',
    
    -- IC相关指标
    ic_mean DECIMAL(8,6) COMMENT '平均IC',
    ic_std DECIMAL(8,6) COMMENT 'IC标准差',
    ic_ir DECIMAL(8,6) COMMENT 'IC信息比率',
    ic_win_rate DECIMAL(5,4) COMMENT 'IC胜率',
    
    -- 收益相关指标
    long_short_return DECIMAL(8,6) COMMENT '多空组合收益',
    max_drawdown DECIMAL(8,6) COMMENT '最大回撤',
    sharpe_ratio DECIMAL(8,6) COMMENT '夏普比率',
    calmar_ratio DECIMAL(8,6) COMMENT 'Calmar比率',
    
    -- 稳定性指标
    factor_exposure_std DECIMAL(8,6) COMMENT '因子暴露度标准差',
    turnover_rate DECIMAL(8,6) COMMENT '换手率',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_factor_date_period (factor_name, evaluation_date, evaluation_period_days),
    INDEX idx_evaluation_date (evaluation_date),
    INDEX idx_factor_name (factor_name)
) COMMENT '因子表现评估表';
```

## 核心算法实现

### 1. 主权重计算引擎
```python
class FactorWeightEngine:
    def __init__(self):
        self.market_adjuster = MarketRegimeWeightAdjuster()
        self.effectiveness_evaluator = FactorEffectivenessEvaluator()
        self.industry_adjuster = IndustrySpecificWeightAdjuster()
        
    def calculate_optimal_weights(self, stock_code, market_data, factor_data):
        """计算最优因子权重"""
        # 1. 获取基础权重
        base_weights = self._get_base_weights(stock_code)
        
        # 2. 市场状态调整
        market_regime = self.market_adjuster.detect_market_regime(market_data)
        regime_adjusted_weights = self.market_adjuster.adjust_weights_by_regime(
            base_weights, market_regime
        )
        
        # 3. 因子有效性调整
        effectiveness_scores = self.effectiveness_evaluator.dynamic_weight_by_effectiveness(
            factor_data['performance_history']
        )
        effectiveness_adjusted_weights = self._apply_effectiveness_adjustment(
            regime_adjusted_weights, effectiveness_scores
        )
        
        # 4. 行业特异性调整
        industry_code = self._get_stock_industry(stock_code)
        final_weights = self.industry_adjuster.adjust_weights_by_industry(
            effectiveness_adjusted_weights, industry_code
        )
        
        # 5. 权重标准化
        normalized_weights = self._normalize_weights(final_weights)
        
        return {
            'stock_code': stock_code,
            'market_regime': market_regime,
            'industry_code': industry_code,
            'weights': normalized_weights,
            'adjustment_details': {
                'base_weights': base_weights,
                'regime_adjusted': regime_adjusted_weights,
                'effectiveness_adjusted': effectiveness_adjusted_weights,
                'industry_adjusted': final_weights
            }
        }
    
    def _normalize_weights(self, weights):
        """权重标准化，确保总和为1"""
        total_weight = 0
        flat_weights = {}
        
        # 展平权重结构
        for category, factors in weights.items():
            for factor_name, weight_info in factors.items():
                weight_key = f"{category}.{factor_name}"
                flat_weights[weight_key] = weight_info.get('final_weight', 
                                                         weight_info.get('adjusted_weight', 
                                                                       weight_info['base_weight']))
                total_weight += flat_weights[weight_key]
        
        # 标准化
        if total_weight > 0:
            normalized_weights = {
                key: weight / total_weight 
                for key, weight in flat_weights.items()
            }
        else:
            # 如果总权重为0，均匀分配
            n_factors = len(flat_weights)
            normalized_weights = {
                key: 1.0 / n_factors 
                for key in flat_weights
            }
        
        return normalized_weights
```

### 2. 权重优化算法
```python
class WeightOptimizer:
    def __init__(self, max_iterations=100, convergence_threshold=1e-6):
        self.max_iterations = max_iterations
        self.convergence_threshold = convergence_threshold
    
    def optimize_weights_by_performance(self, factor_returns, target_return=None, max_risk=None):
        """基于历史表现优化权重"""
        n_factors = len(factor_returns.columns)
        
        # 计算期望收益和协方差矩阵
        expected_returns = factor_returns.mean()
        cov_matrix = factor_returns.cov()
        
        # 目标函数：最大化夏普比率
        def objective(weights):
            portfolio_return = np.sum(weights * expected_returns)
            portfolio_risk = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
            
            if portfolio_risk == 0:
                return -float('inf')
            
            sharpe_ratio = portfolio_return / portfolio_risk
            return -sharpe_ratio  # 最小化负夏普比率
        
        # 约束条件
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x) - 1}  # 权重和为1
        ]
        
        if target_return is not None:
            constraints.append({
                'type': 'eq',
                'fun': lambda x: np.sum(x * expected_returns) - target_return
            })
        
        if max_risk is not None:
            constraints.append({
                'type': 'ineq',
                'fun': lambda x: max_risk - np.sqrt(np.dot(x.T, np.dot(cov_matrix, x)))
            })
        
        # 边界条件：权重在0-1之间
        bounds = [(0, 1) for _ in range(n_factors)]
        
        # 初始权重
        x0 = np.array([1/n_factors] * n_factors)
        
        # 优化
        result = minimize(
            objective, x0,
            method='SLSQP',
            bounds=bounds,
            constraints=constraints
        )
        
        if result.success:
            return {
                'optimal_weights': dict(zip(factor_returns.columns, result.x)),
                'expected_return': np.sum(result.x * expected_returns),
                'expected_risk': np.sqrt(np.dot(result.x.T, np.dot(cov_matrix, result.x))),
                'sharpe_ratio': -result.fun,
                'success': True
            }
        else:
            return {'success': False, 'message': result.message}
```

### 3. 实时权重更新
```python
class RealTimeWeightUpdater:
    def __init__(self, update_frequency='daily'):
        self.update_frequency = update_frequency
        self.last_update = None
        
    def should_update_weights(self):
        """判断是否需要更新权重"""
        if self.last_update is None:
            return True
        
        now = datetime.now()
        if self.update_frequency == 'daily':
            return (now - self.last_update).days >= 1
        elif self.update_frequency == 'weekly':
            return (now - self.last_update).days >= 7
        elif self.update_frequency == 'monthly':
            return (now - self.last_update).days >= 30
        
        return False
    
    def update_weights_batch(self, stock_list, market_data):
        """批量更新股票权重"""
        weight_engine = FactorWeightEngine()
        updated_weights = {}
        
        for stock_code in stock_list:
            try:
                # 获取股票相关数据
                factor_data = self._get_factor_data(stock_code)
                
                # 计算新权重
                weight_result = weight_engine.calculate_optimal_weights(
                    stock_code, market_data, factor_data
                )
                
                updated_weights[stock_code] = weight_result
                
                # 保存到数据库
                self._save_weights_to_db(weight_result)
                
            except Exception as e:
                logger.error(f"更新股票 {stock_code} 权重失败: {e}")
                continue
        
        self.last_update = datetime.now()
        return updated_weights
    
    def _save_weights_to_db(self, weight_result):
        """保存权重到数据库"""
        stock_code = weight_result['stock_code']
        weights = weight_result['weights']
        
        for factor_key, weight in weights.items():
            category, factor_name = factor_key.split('.')
            
            # 更新factor_weight_config表
            sql = """
            UPDATE factor_weight_config 
            SET current_weight = %s, last_updated = NOW()
            WHERE factor_category = %s AND factor_name = %s 
            AND (industry_code = %s OR industry_code IS NULL)
            AND market_regime = %s
            """
            
            params = (
                weight, category, factor_name,
                weight_result['industry_code'],
                weight_result['market_regime']
            )
            
            # 执行数据库更新
            execute_sql(sql, params)
```

## API接口设计

### 1. 权重查询接口
```python
# 获取股票当前权重配置
GET /api/weights/{stock_code}/current
GET /api/weights/{stock_code}/history?days=30

# 批量查询权重
POST /api/weights/batch
{
    "stock_codes": ["000001", "000002"],
    "market_regime": "bull_market"
}

# 获取因子权重排行
GET /api/weights/factors/ranking?category=profitability
```

### 2. 权重配置接口
```python
# 更新权重配置
PUT /api/weights/config/{config_id}
{
    "base_weight": 0.15,
    "min_weight": 0.08,
    "max_weight": 0.25
}

# 批量权重重算
POST /api/weights/recalculate
{
    "stock_codes": ["000001", "000002"],
    "force_update": true
}
```

### 3. 权重分析接口
```python
# 权重敏感性分析
GET /api/weights/{stock_code}/sensitivity?factor=roe
GET /api/weights/optimization/backtest?start_date=2023-01-01

# 权重有效性评估
GET /api/weights/effectiveness?period=252
GET /api/weights/factors/{factor_name}/performance
```

## 实施计划

### 第一阶段：基础框架（2-3天）
1. 设计权重配置数据库结构
2. 实现基础权重计算框架
3. 建立市场状态识别机制
4. 完成基础权重调整算法

### 第二阶段：动态调整（3-4天）
1. 实现因子有效性评估
2. 开发行业特异性调整
3. 建立权重优化算法
4. 完善实时更新机制

### 第三阶段：系统集成（2-3天）
1. 与第四层模块数据对接
2. 实现批量权重计算
3. 建立权重变化监控
4. 完善异常处理机制

### 第四阶段：服务接口（1-2天）
1. 开发RESTful API接口
2. 实现权重查询和配置
3. 建立监控dashboard
4. 完成性能测试优化

## 成功指标
- 权重调整及时性 < 1小时
- 因子有效性评估准确率 > 80%
- 权重优化后组合表现提升 > 5%
- 系统响应时间 < 500ms
- 权重配置覆盖率 > 95%
- 动态调整频率适中（避免过度调整）

## 维护和监控

### 定期维护
- **每日**: 更新因子有效性评估，调整实时权重
- **每周**: 评估权重调整效果，优化参数设置
- **每月**: 审查权重配置合理性，更新基础权重
- **每季度**: 全面评估权重体系效果，优化算法模型

### 质量监控
- 权重变化异常检测
- 因子有效性下降预警
- 权重配置一致性检查
- 组合表现归因分析

该模块为第六层预测分析提供精确的权重参数，确保模型在不同市场环境下的稳定性和有效性。
