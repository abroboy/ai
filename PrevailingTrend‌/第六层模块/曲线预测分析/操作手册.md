# 曲线预测分析模块 - 操作手册

## 模块概述
曲线预测分析模块是大势所趋风险框架的最高层级，负责整合所有底层数据和分析结果，运用机器学习和量化模型进行股价趋势预测、风险事件预警和投资组合优化。该模块为投资决策提供前瞻性的量化支持。

## 数据输入依赖

### 全量数据输入
- **第一层至第五层模块**: 所有原始数据和处理结果
- **公司分值表**: 综合评分和排名数据
- **行业分值表**: 行业比较和相对表现
- **对象因子权重表**: 动态权重和因子暴露

### 市场数据补充
- **股票价格数据**: 日/分钟级价格、成交量
- **指数数据**: 市场基准和行业指数
- **宏观经济数据**: GDP、CPI、利率等
- **国际市场数据**: 外围市场影响因子

## 预测模型体系

### 1. 时间序列预测模型

#### LSTM深度学习模型
```java
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, BatchNormalization

class StockPriceLSTM:
    def __init__(self, sequence_length=60, features=10):
        self.sequence_length = sequence_length
        self.features = features
        self.model = self._build_model()
    
    def _build_model(self):
        """构建LSTM模型"""
        model = Sequential([
            LSTM(128, return_sequences=True, input_shape=(self.sequence_length, self.features)),
            BatchNormalization(),
            Dropout(0.2),
            
            LSTM(64, return_sequences=True),
            BatchNormalization(),
            Dropout(0.2),
            
            LSTM(32, return_sequences=False),
            BatchNormalization(),
            Dropout(0.2),
            
            Dense(16, activation='relu'),
            Dense(1, activation='linear')  # 预测价格
        ])
        
        model.compile(
            optimizer='adam',
            loss='mse',
            metrics=['mae']
        )
        
        return model
    
    def prepare_data(self, data):
        """准备训练数据"""
        features = [
            'close_price', 'volume', 'high', 'low', 'open',
            'rsi', 'macd', 'bollinger_upper', 'bollinger_lower',
            'company_score'  # 来自第四层模块
        ]
        
        X, y = [], []
        for i in range(self.sequence_length, len(data)):
            X.append(data[features].iloc[i-self.sequence_length:i].values)
            y.append(data['close_price'].iloc[i])
        
        return np.array(X), np.array(y)
    
    def train(self, X_train, y_train, epochs=100, batch_size=32):
        """训练模型"""
        history = self.model.fit(
            X_train, y_train,
            epochs=epochs,
            batch_size=batch_size,
            validation_split=0.2,
            callbacks=[
                tf.keras.callbacks.EarlyStopping(patience=10),
                tf.keras.callbacks.ReduceLROnPlateau(factor=0.5, patience=5)
            ]
        )
        return history
    
    def predict(self, X_test):
        """预测股价"""
        return self.model.predict(X_test)
```

#### ARIMA-GARCH组合模型
```java
from arch import arch_model
from statsmodels.tsa.arima.model import ARIMA
import numpy as np

class ARIMAGARCHModel:
    def __init__(self):
        self.arima_model = None
        self.garch_model = None
        
    def fit(self, returns_data):
        """拟合ARIMA-GARCH模型"""
        # 第一步：拟合ARIMA模型
        self.arima_model = ARIMA(returns_data, order=(1, 1, 1))
        arima_result = self.arima_model.fit()
        
        # 第二步：对残差拟合GARCH模型
        residuals = arima_result.resid
        self.garch_model = arch_model(residuals, vol='GARCH', p=1, q=1)
        garch_result = self.garch_model.fit()
        
        return arima_result, garch_result
    
    def forecast(self, steps=5):
        """预测收益率和波动率"""
        # 预测条件均值
        mean_forecast = self.arima_model.forecast(steps=steps)
        
        # 预测条件方差
        variance_forecast = self.garch_model.forecast(horizon=steps)
        
        return mean_forecast, variance_forecast
```

### 2. 机器学习集成模型

#### 随机森林回归模型
```java
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
import pandas as pd

class StockPredictionRF:
    def __init__(self, n_estimators=200, max_depth=10):
        self.model = RandomForestRegressor(
            n_estimators=n_estimators,
            max_depth=max_depth,
            random_state=42,
            n_jobs=-1
        )
        self.scaler = StandardScaler()
        self.feature_importance = None
    
    def prepare_features(self, data):
        """准备机器学习特征"""
        features = []
        
        # 技术指标特征
        features.extend([
            'rsi_14', 'macd_signal', 'bollinger_position',
            'volume_sma_ratio', 'price_sma_ratio'
        ])
        
        # 基本面特征 (来自前层模块)
        features.extend([
            'company_total_score', 'financial_health_score',
            'pe_ratio', 'pb_ratio', 'roe', 'debt_ratio'
        ])
        
        # 市场特征
        features.extend([
            'market_beta', 'correlation_with_index',
            'relative_strength', 'momentum_score'
        ])
        
        # 情绪特征 (来自热点数据表)
        features.extend([
            'social_sentiment_score', 'media_attention',
            'analyst_rating_change', 'institutional_flow'
        ])
        
        # 宏观特征
        features.extend([
            'interest_rate', 'vix_level', 'usd_cny_rate',
            'industry_performance'
        ])
        
        return data[features]
    
    def train(self, X_train, y_train):
        """训练随机森林模型"""
        X_train_scaled = self.scaler.fit_transform(X_train)
        self.model.fit(X_train_scaled, y_train)
        
        # 保存特征重要性
        self.feature_importance = pd.DataFrame({
            'feature': X_train.columns,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False)
        
        return self.feature_importance
    
    def predict(self, X_test):
        """预测股价变动"""
        X_test_scaled = self.scaler.transform(X_test)
        return self.model.predict(X_test_scaled)
```

#### XGBoost模型
```java
import xgboost as xgb
from sklearn.model_selection import GridSearchCV

class StockPredictionXGB:
    def __init__(self):
        self.model = None
        self.best_params = None
    
    def optimize_hyperparameters(self, X_train, y_train):
        """超参数优化"""
        param_grid = {
            'n_estimators': [100, 200, 300],
            'max_depth': [3, 5, 7],
            'learning_rate': [0.01, 0.1, 0.2],
            'subsample': [0.8, 0.9, 1.0],
            'colsample_bytree': [0.8, 0.9, 1.0]
        }
        
        xgb_model = xgb.XGBRegressor(random_state=42)
        grid_search = GridSearchCV(
            xgb_model, param_grid,
            cv=5, scoring='neg_mean_squared_error',
            n_jobs=-1, verbose=1
        )
        
        grid_search.fit(X_train, y_train)
        self.best_params = grid_search.best_params_
        self.model = grid_search.best_estimator_
        
        return self.best_params
    
    def predict_with_uncertainty(self, X_test, n_estimators=100):
        """预测并估计不确定性"""
        predictions = []
        
        for i in range(n_estimators):
            # 使用bootstrap采样训练多个模型
            model_i = xgb.XGBRegressor(**self.best_params, random_state=i)
            # 这里需要重新训练，实际应用中可以预先训练好
            predictions.append(model_i.predict(X_test))
        
        predictions = np.array(predictions)
        mean_pred = np.mean(predictions, axis=0)
        std_pred = np.std(predictions, axis=0)
        
        return mean_pred, std_pred
```

### 3. 模型集成框架
```java
class EnsemblePredictionModel:
    def __init__(self):
        self.models = {
            'lstm': StockPriceLSTM(),
            'rf': StockPredictionRF(),
            'xgb': StockPredictionXGB(),
            'arima_garch': ARIMAGARCHModel()
        }
        self.weights = {
            'lstm': 0.3,
            'rf': 0.25,
            'xgb': 0.25,
            'arima_garch': 0.2
        }
    
    def train_all_models(self, data):
        """训练所有模型"""
        results = {}
        
        # 准备不同模型的数据格式
        lstm_X, lstm_y = self.models['lstm'].prepare_data(data)
        ml_features = self.models['rf'].prepare_features(data)
        returns_data = data['returns'].dropna()
        
        # 训练各模型
        results['lstm'] = self.models['lstm'].train(lstm_X, lstm_y)
        results['rf'] = self.models['rf'].train(ml_features[:-1], data['close_price'][1:])
        results['xgb'] = self.models['xgb'].optimize_hyperparameters(ml_features[:-1], data['close_price'][1:])
        results['arima_garch'] = self.models['arima_garch'].fit(returns_data)
        
        return results
    
    def predict_ensemble(self, test_data):
        """集成预测"""
        predictions = {}
        
        # 各模型预测
        lstm_pred = self.models['lstm'].predict(test_data['lstm_format'])
        rf_pred = self.models['rf'].predict(test_data['ml_features'])
        xgb_pred = self.models['xgb'].model.predict(test_data['ml_features'])
        arima_pred, _ = self.models['arima_garch'].forecast(steps=1)
        
        predictions['lstm'] = lstm_pred
        predictions['rf'] = rf_pred
        predictions['xgb'] = xgb_pred
        predictions['arima_garch'] = arima_pred
        
        # 加权集成
        ensemble_pred = sum(
            predictions[model] * self.weights[model] 
            for model in self.weights
        )
        
        return ensemble_pred, predictions
    
    def dynamic_weight_adjustment(self, historical_performance):
        """动态调整模型权重"""
        # 基于历史表现调整权重
        performance_scores = {}
        for model in self.models:
            mse = np.mean((historical_performance[model]['actual'] - 
                          historical_performance[model]['predicted']) ** 2)
            performance_scores[model] = 1 / (1 + mse)  # MSE越小，权重越大
        
        # 归一化权重
        total_score = sum(performance_scores.values())
        self.weights = {
            model: score / total_score 
            for model, score in performance_scores.items()
        }
        
        return self.weights
```

## 风险预警系统

### 1. 实时风险监控
```java
class RealTimeRiskMonitor:
    def __init__(self):
        self.risk_thresholds = {
            'price_volatility': 0.05,      # 5%日波动率
            'volume_spike': 3.0,           # 3倍平均成交量
            'sentiment_drop': -0.3,        # 情绪得分下降30%
            'score_decline': -10,          # 综合得分下降10分
            'liquidity_risk': 0.02         # 2%买卖价差
        }
        
    def check_risk_signals(self, stock_data):
        """检查风险信号"""
        risk_alerts = []
        
        # 价格波动风险
        if stock_data['daily_volatility'] > self.risk_thresholds['price_volatility']:
            risk_alerts.append({
                'type': 'high_volatility',
                'severity': 'medium',
                'value': stock_data['daily_volatility'],
                'threshold': self.risk_thresholds['price_volatility']
            })
        
        # 成交量异常
        volume_ratio = stock_data['current_volume'] / stock_data['avg_volume_20d']
        if volume_ratio > self.risk_thresholds['volume_spike']:
            risk_alerts.append({
                'type': 'volume_spike',
                'severity': 'high',
                'value': volume_ratio,
                'threshold': self.risk_thresholds['volume_spike']
            })
        
        # 情绪急剧恶化
        sentiment_change = (stock_data['sentiment_current'] - 
                           stock_data['sentiment_1w_ago']) / stock_data['sentiment_1w_ago']
        if sentiment_change < self.risk_thresholds['sentiment_drop']:
            risk_alerts.append({
                'type': 'sentiment_deterioration',
                'severity': 'medium',
                'value': sentiment_change,
                'threshold': self.risk_thresholds['sentiment_drop']
            })
        
        # 综合得分下降
        score_change = stock_data['score_current'] - stock_data['score_1m_ago']
        if score_change < self.risk_thresholds['score_decline']:
            risk_alerts.append({
                'type': 'score_decline',
                'severity': 'high',
                'value': score_change,
                'threshold': self.risk_thresholds['score_decline']
            })
        
        return risk_alerts
    
    def generate_risk_report(self, portfolio_stocks):
        """生成投资组合风险报告"""
        portfolio_risk = {
            'overall_risk_level': 'low',
            'individual_risks': {},
            'concentration_risk': {},
            'correlation_risk': {},
            'recommendations': []
        }
        
        high_risk_count = 0
        total_value = sum(stock['position_value'] for stock in portfolio_stocks)
        
        for stock in portfolio_stocks:
            stock_risks = self.check_risk_signals(stock)
            if stock_risks:
                portfolio_risk['individual_risks'][stock['code']] = stock_risks
                if any(risk['severity'] == 'high' for risk in stock_risks):
                    high_risk_count += 1
        
        # 评估整体风险水平
        if high_risk_count > len(portfolio_stocks) * 0.3:
            portfolio_risk['overall_risk_level'] = 'high'
        elif high_risk_count > len(portfolio_stocks) * 0.1:
            portfolio_risk['overall_risk_level'] = 'medium'
        
        return portfolio_risk
```

### 2. 事件驱动预警
```java
class EventDrivenAlert:
    def __init__(self):
        self.event_impact_models = {
            'earnings_announcement': self._earnings_impact_model,
            'policy_change': self._policy_impact_model,
            'industry_event': self._industry_impact_model,
            'macro_event': self._macro_impact_model
        }
    
    def process_event(self, event_data):
        """处理事件并生成预警"""
        event_type = event_data['type']
        if event_type in self.event_impact_models:
            impact_assessment = self.event_impact_models[event_type](event_data)
            
            if impact_assessment['severity'] >= 0.7:
                return self._generate_alert(event_data, impact_assessment)
        
        return None
    
    def _earnings_impact_model(self, event_data):
        """财报事件影响评估"""
        # 实际vs预期差异
        earnings_surprise = (event_data['actual_eps'] - event_data['expected_eps']) / event_data['expected_eps']
        
        # 收入增长情况
        revenue_growth = event_data['revenue_growth_yoy']
        
        # 综合影响评分
        impact_score = abs(earnings_surprise) * 0.6 + abs(revenue_growth - 0.15) * 0.4
        
        return {
            'severity': min(1.0, impact_score),
            'direction': 'positive' if earnings_surprise > 0 else 'negative',
            'details': {
                'earnings_surprise': earnings_surprise,
                'revenue_growth': revenue_growth
            }
        }
    
    def _generate_alert(self, event_data, impact_assessment):
        """生成预警信息"""
        return {
            'alert_id': f"EVENT_{event_data['timestamp']}_{event_data['stock_code']}",
            'stock_code': event_data['stock_code'],
            'event_type': event_data['type'],
            'severity': impact_assessment['severity'],
            'expected_impact': impact_assessment['direction'],
            'probability': self._calculate_probability(impact_assessment),
            'time_horizon': '1-3 trading days',
            'recommended_action': self._get_recommendation(impact_assessment),
            'details': impact_assessment['details']
        }
```

## 投资组合优化

### 1. 现代投资组合理论
```java
import numpy as np
from scipy.optimize import minimize
import pandas as pd

class PortfolioOptimizer:
    def __init__(self, expected_returns, cov_matrix, risk_free_rate=0.03):
        self.expected_returns = expected_returns
        self.cov_matrix = cov_matrix
        self.risk_free_rate = risk_free_rate
        self.n_assets = len(expected_returns)
    
    def optimize_portfolio(self, objective='sharpe', constraints=None):
        """优化投资组合"""
        # 初始权重
        x0 = np.array([1/self.n_assets] * self.n_assets)
        
        # 约束条件
        bounds = [(0, 1) for _ in range(self.n_assets)]  # 权重在0-1之间
        
        # 权重和为1的约束
        constraints_list = [{'type': 'eq', 'fun': lambda x: np.sum(x) - 1}]
        
        # 添加自定义约束
        if constraints:
            constraints_list.extend(constraints)
        
        # 选择目标函数
        if objective == 'sharpe':
            objective_func = self._negative_sharpe_ratio
        elif objective == 'min_variance':
            objective_func = self._portfolio_variance
        elif objective == 'max_return':
            objective_func = self._negative_return
        
        # 优化
        result = minimize(
            objective_func, x0,
            method='SLSQP',
            bounds=bounds,
            constraints=constraints_list
        )
        
        if result.success:
            optimal_weights = result.x
            portfolio_return = np.sum(optimal_weights * self.expected_returns)
            portfolio_risk = np.sqrt(np.dot(optimal_weights.T, 
                                           np.dot(self.cov_matrix, optimal_weights)))
            sharpe_ratio = (portfolio_return - self.risk_free_rate) / portfolio_risk
            
            return {
                'weights': optimal_weights,
                'expected_return': portfolio_return,
                'risk': portfolio_risk,
                'sharpe_ratio': sharpe_ratio,
                'success': True
            }
        else:
            return {'success': False, 'message': result.message}
    
    def _negative_sharpe_ratio(self, weights):
        """负夏普比率（用于最大化）"""
        portfolio_return = np.sum(weights * self.expected_returns)
        portfolio_risk = np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))
        sharpe_ratio = (portfolio_return - self.risk_free_rate) / portfolio_risk
        return -sharpe_ratio
    
    def _portfolio_variance(self, weights):
        """投资组合方差"""
        return np.dot(weights.T, np.dot(self.cov_matrix, weights))
    
    def _negative_return(self, weights):
        """负期望收益（用于最大化收益）"""
        return -np.sum(weights * self.expected_returns)
```

### 2. Black-Litterman模型
```java
class BlackLittermanOptimizer:
    def __init__(self, market_caps, returns_data, risk_aversion=3.0):
        self.market_caps = market_caps
        self.returns_data = returns_data
        self.risk_aversion = risk_aversion
        
    def calculate_implied_returns(self):
        """计算隐含收益率"""
        # 市场权重
        w_market = self.market_caps / self.market_caps.sum()
        
        # 协方差矩阵
        cov_matrix = self.returns_data.cov().values
        
        # 隐含收益率 = 风险厌恶系数 × 协方差矩阵 × 市场权重
        implied_returns = self.risk_aversion * np.dot(cov_matrix, w_market)
        
        return implied_returns
    
    def incorporate_views(self, picking_matrix, views, view_uncertainty):
        """融入投资观点"""
        # 先验参数
        pi = self.calculate_implied_returns()  # 隐含收益率
        tau = 0.025  # 不确定性参数
        sigma = self.returns_data.cov().values  # 协方差矩阵
        
        # 观点参数
        P = picking_matrix  # 选择矩阵
        Q = views          # 观点向量
        omega = view_uncertainty  # 观点不确定性矩阵
        
        # Black-Litterman公式
        # 新的期望收益率
        M1 = np.linalg.inv(tau * sigma)
        M2 = np.dot(P.T, np.dot(np.linalg.inv(omega), P))
        M3 = np.dot(np.linalg.inv(tau * sigma), pi)
        M4 = np.dot(P.T, np.dot(np.linalg.inv(omega), Q))
        
        mu_bl = np.dot(np.linalg.inv(M1 + M2), M3 + M4)
        
        # 新的协方差矩阵
        cov_bl = np.linalg.inv(M1 + M2)
        
        return mu_bl, cov_bl
```

## API接口设计

### 1. 预测接口
```java
# 股价预测
GET /api/prediction/{stock_code}/price?horizon=5d
POST /api/prediction/batch
{
    "stock_codes": ["000001", "000002"],
    "horizon": "1m",
    "models": ["lstm", "rf", "ensemble"]
}

# 趋势预测
GET /api/prediction/{stock_code}/trend?confidence=0.95
GET /api/prediction/market/trend?index=000001.SH
```

### 2. 风险预警接口
```java
# 实时风险监控
GET /api/risk/monitor/{stock_code}
GET /api/risk/portfolio?portfolio_id=123

# 风险预警
GET /api/alerts/active?severity=high
POST /api/alerts/subscribe
{
    "stock_codes": ["000001"],
    "alert_types": ["price_volatility", "volume_spike"],
    "notification_channels": ["email", "sms"]
}
```

### 3. 投资组合优化接口
```java
# 组合优化
POST /api/portfolio/optimize
{
    "stock_codes": ["000001", "000002", "000003"],
    "objective": "sharpe",
    "constraints": {
        "max_weight": 0.3,
        "sector_limits": {"technology": 0.4}
    }
}

# 再平衡建议
GET /api/portfolio/{portfolio_id}/rebalance
POST /api/portfolio/backtest
```

## 实施计划

### 第一阶段：模型开发（5-6天）
1. 开发时间序列预测模型
2. 实现机器学习模型
3. 建立模型集成框架
4. 完成模型训练和验证

### 第二阶段：风险系统（3-4天）
1. 实现实时风险监控
2. 开发事件驱动预警
3. 建立风险评估体系
4. 完善预警通知机制

### 第三阶段：组合优化（3-4天）
1. 实现投资组合优化算法
2. 开发再平衡建议功能
3. 建立回测验证系统
4. 完善优化约束条件

### 第四阶段：系统集成（2-3天）
1. 整合所有预测功能
2. 建立统一API接口
3. 完善监控和日志
4. 进行全面测试

## 成功指标
- 预测准确率 > 65%（方向预测）
- 风险预警及时性 < 5分钟
- 组合优化收益 > 基准10%
- 系统响应时间 < 2秒
- 模型稳定性 > 95%
- 预警假阳性率 < 15%

## 维护和监控

### 模型维护
- **每日**: 更新预测结果，监控模型表现
- **每周**: 重新训练快速适应模型
- **每月**: 评估模型效果，调整参数
- **每季度**: 全面审查模型架构，升级算法

### 质量监控
- 预测准确率实时跟踪
- 模型漂移检测
- 风险预警效果评估
- 组合优化收益跟踪

该模块作为整个风险框架的智能大脑，为投资决策提供科学的量化支持和前瞻性指导。


