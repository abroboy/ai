## 集成指南

### 1. 与第五层权重配置层集成

曲线预测分析模块可以与第五层权重配置层紧密集成，利用动态调整的因子权重优化预测模型。

#### 集成步骤：

1. 从权重配置层获取最新权重：
```python
import requests

# 获取最新权重配置
response = requests.get('http://localhost:5000/api/weights/latest')
weights = response.json()['data']

# 使用权重进行预测
prediction_response = requests.post(
    'http://localhost:5000/api/predict',
    json={
        'data': [...],
        'model_type': 'ensemble',
        'weights': weights,
        'steps': 30
    }
)
```

2. 将预测结果反馈给权重配置层：
```python
# 获取预测结果
predictions = prediction_response.json()['data']

# 将预测结果反馈给权重配置层
feedback_response = requests.post(
    'http://localhost:5000/api/weights/feedback',
    json={
        'predictions': predictions,
        'actual_data': [...],
        'model_id': 'model_123'
    }
)
```

### 2. 与管理台集成

曲线预测分析模块可以与管理台集成，提供可视化界面进行模型管理和预测结果展示。

#### 集成步骤：

1. 在管理台中添加预测模块页面：
```html
<!-- 预测模块页面 -->
<div class="prediction-module">
  <h2>趋势预测分析</h2>
  
  <!-- 模型选择 -->
  <div class="model-selection">
    <select id="model-select">
      <option value="">选择模型</option>
    </select>
    <button id="create-model-btn">创建模型</button>
  </div>
  
  <!-- 预测参数 -->
  <div class="prediction-params">
    <label>预测步数：</label>
    <input type="number" id="steps" value="30" min="1" max="365">
    <button id="predict-btn">开始预测</button>
  </div>
  
  <!-- 预测结果 -->
  <div class="prediction-results">
    <div id="prediction-chart"></div>
    <div id="prediction-table"></div>
  </div>
</div>
```

2. 添加JavaScript代码处理API调用：
```javascript
// 加载模型列表
function loadModels() {
  fetch('/api/models')
    .then(response => response.json())
    .then(data => {
      const select = document.getElementById('model-select');
      select.innerHTML = '<option value="">选择模型</option>';
      
      data.data.forEach(model => {
        const option = document.createElement('option');
        option.value = model.id;
        option.textContent = model.name;
        select.appendChild(option);
      });
    });
}

// 进行预测
function predict() {
  const modelId = document.getElementById('model-select').value;
  const steps = document.getElementById('steps').value;
  
  if (!modelId) {
    alert('请选择模型');
    return;
  }
  
  fetch(`/api/models/${modelId}/predict`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      steps: parseInt(steps)
    })
  })
    .then(response => response.json())
    .then(data => {
      // 显示预测图表
      document.getElementById('prediction-chart').innerHTML = `<img src="${data.chart_url}" alt="预测图表">`;
      
      // 显示预测数据表格
      const table = document.createElement('table');
      table.innerHTML = `
        <thead>
          <tr>
            <th>日期</th>
            <th>预测值</th>
            ${data.data[0].lower_bound ? '<th>下限</th><th>上限</th>' : ''}
          </tr>
        </thead>
        <tbody>
          ${data.data.map(item => `
            <tr>
              <td>${item.date}</td>
              <td>${item.prediction.toFixed(2)}</td>
              ${item.lower_bound ? `<td>${item.lower_bound.toFixed(2)}</td><td>${item.upper_bound.toFixed(2)}</td>` : ''}
            </tr>
          `).join('')}
        </tbody>
      `;
      
      document.getElementById('prediction-table').innerHTML = '';
      document.getElementById('prediction-table').appendChild(table);
    });
}

// 初始化
document.addEventListener('DOMContentLoaded', () => {
  loadModels();
  
  document.getElementById('predict-btn').addEventListener('click', predict);
  document.getElementById('create-model-btn').addEventListener('click', () => {
    // 显示创建模型对话框
    // ...
  });
});
```

### 3. 与数据库集成

曲线预测分析模块需要与数据库集成，存储模型信息、训练数据和预测结果。

#### 数据库表设计：

1. 模型表（models）：
```sql
CREATE TABLE models (
  id VARCHAR(50) PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  type VARCHAR(20) NOT NULL,
  description TEXT,
  created_at TIMESTAMP NOT NULL,
  parameters JSON
);
```

2. 预测结果表（predictions）：
```sql
CREATE TABLE predictions (
  id INT AUTO_INCREMENT PRIMARY KEY,
  model_id VARCHAR(50) NOT NULL,
  prediction_date TIMESTAMP NOT NULL,
  target_date DATE NOT NULL,
  predicted_value DOUBLE NOT NULL,
  lower_bound DOUBLE,
  upper_bound DOUBLE,
  FOREIGN KEY (model_id) REFERENCES models(id)
);
```

3. 实际数据表（actual_data）：
```sql
CREATE TABLE actual_data (
  id INT AUTO_INCREMENT PRIMARY KEY,
  date DATE NOT NULL,
  value DOUBLE NOT NULL,
  source VARCHAR(50),
  UNIQUE KEY (date, source)
);
```

#### 数据库集成代码示例：

```python
import mysql.connector
import json
from datetime import datetime

class DatabaseConnector:
    def __init__(self, host, user, password, database):
        self.conn = mysql.connector.connect(
            host=host,
            user=user,
            password=password,
            database=database
        )
        self.cursor = self.conn.cursor()
    
    def save_model(self, model_id, name, model_type, description, parameters):
        query = """
        INSERT INTO models (id, name, type, description, created_at, parameters)
        VALUES (%s, %s, %s, %s, %s, %s)
        """
        self.cursor.execute(
            query,
            (model_id, name, model_type, description, datetime.now(), json.dumps(parameters))
        )
        self.conn.commit()
    
    def save_predictions(self, model_id, predictions):
        query = """
        INSERT INTO predictions (model_id, prediction_date, target_date, predicted_value, lower_bound, upper_bound)
        VALUES (%s, %s, %s, %s, %s, %s)
        """
        prediction_date = datetime.now()
        
        for pred in predictions:
            target_date = pred['date']
            predicted_value = pred['prediction']
            lower_bound = pred.get('lower_bound')
            upper_bound = pred.get('upper_bound')
            
            self.cursor.execute(
                query,
                (model_id, prediction_date, target_date, predicted_value, lower_bound, upper_bound)
            )
        
        self.conn.commit()
    
    def close(self):
        self.cursor.close()
        self.conn.close()